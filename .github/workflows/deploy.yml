name: Deploy to Production

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (optional, defaults to latest tag)'
        required: false
        type: string

env:
  NODE_VERSION: '18'
  DOCKER_REGISTRY: 'docker.io'
  IMAGE_NAME: 'skill-repeater-front'
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}

jobs:
  # Quality Assurance
  quality-assurance:
    name: Quality Assurance
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up Node.js ${{ env.NODE_VERSION }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Cache npm packages
      uses: actions/cache@v4
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: ${{ runner.os }}-node
        
    # Quick Quality Checks
    - name: Quick Quality Checks
      run: |
        echo "ğŸ” Running quick quality checks..."
        npm ci
        npm run lint
        npm run build
        
    # Upload Quality Reports
    - name: Upload Quality Reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: quality-reports-${{ github.run_number }}
        path: |
          dist/
        retention-days: 30

  # Build and Package
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: quality-assurance
    if: needs.quality-assurance.result == 'success'
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      trigger_type: ${{ steps.version.outputs.trigger_type }}
      image-tag: ${{ steps.build.outputs.image-tag }}
      image-tag-date: ${{ steps.build.outputs.image-tag-date }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Node.js ${{ env.NODE_VERSION }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Calculate Version
      id: version
      run: |
        if [[ "${{ github.event_name }}" == "push" ]]; then
          # Extract version from tag (remove 'v' prefix)
          VERSION=${GITHUB_REF#refs/tags/}
          VERSION=${VERSION#v}  # Remove 'v' prefix if present
          TAG="v$VERSION"
          TRIGGER_TYPE="tag"
        else
          # Manual dispatch - use provided version or latest tag
          if [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            # Get latest tag
            VERSION=$(git describe --tags --abbrev=0 | sed 's/^v//')
          fi
          TAG="v$VERSION"
          TRIGGER_TYPE="manual"
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "trigger_type=$TRIGGER_TYPE" >> $GITHUB_OUTPUT
        echo "ğŸ“¦ Version: $VERSION"
        echo "ğŸ·ï¸ Tag: $TAG"
        echo "ğŸ”§ Trigger: $TRIGGER_TYPE"
        
    - name: Set up Docker Build
      uses: docker/setup-buildx-action@v3
      
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
        
    - name: Build and Push to Docker Hub
      id: build
      run: |
        echo "ğŸ—ï¸ Building application..."
        npm ci
        npm run build
        
        # Create Docker Hub image tags
        TAG_DATE=$(date +%Y%m%d%H%M%S)
        IMAGE_TAG="${{ env.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}"
        IMAGE_TAG_DATE="${{ env.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:$TAG_DATE"
        
        echo "ğŸ³ Building Docker image..."
        docker buildx build --platform linux/amd64 \
          --build-arg VITE_API_URL=https://api.posadskiy.com/skill-repeater \
          --build-arg VITE_AUTH_URL=https://api.posadskiy.com/auth \
          --build-arg VITE_USER_URL=https://api.posadskiy.com/user \
          -f Dockerfile.prod \
          -t $IMAGE_TAG \
          -t $IMAGE_TAG_DATE \
          . --push
        
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "image-tag-date=$IMAGE_TAG_DATE" >> $GITHUB_OUTPUT
        echo "ğŸ³ Image tags: $IMAGE_TAG, $IMAGE_TAG_DATE"
        
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts-${{ github.run_number }}
        path: |
          dist/
        retention-days: 30
        
    - name: Create Build Summary
      run: |
        echo "ğŸ“‹ Build Summary" > build-summary.txt
        echo "Version: ${{ steps.version.outputs.version }}" >> build-summary.txt
        echo "Image Tag: ${{ steps.build.outputs.image-tag }}" >> build-summary.txt
        echo "Image Tag Date: ${{ steps.build.outputs.image-tag-date }}" >> build-summary.txt
        echo "Registry: Docker Hub (${{ env.DOCKERHUB_USERNAME }})" >> build-summary.txt
        echo "Build Date: $(date)" >> build-summary.txt
        
    - name: Upload Build Summary
      uses: actions/upload-artifact@v4
      with:
        name: build-summary-${{ github.run_number }}
        path: build-summary.txt
        retention-days: 30

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [quality-assurance, build]
    if: needs.quality-assurance.result == 'success' && needs.build.result == 'success'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download Build Artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts-${{ github.run_number }}
        path: artifacts/
        
    - name: Download Build Summary
      uses: actions/download-artifact@v4
      with:
        name: build-summary-${{ github.run_number }}
        path: ./
        
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      
    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config
        
    - name: Deploy to Production Environment
      run: |
        echo "ğŸ” Deploying skill-repeater-front to production environment..."
        
        # Configuration
        NAMESPACE="${{ secrets.K8S_NAMESPACE || 'skill-repeater' }}"
        VERSION="${{ needs.build.outputs.version }}"
        IMAGE_TAG="${{ needs.build.outputs.image-tag }}"
        DOCKERHUB_USERNAME="${{ env.DOCKERHUB_USERNAME }}"
        
        echo "ğŸ“‹ Production Deployment Plan:"
        echo "- Environment: Production"
        echo "- Application: Skill Repeater Frontend"
        echo "- Version: $VERSION"
        echo "- Image: $IMAGE_TAG"
        echo "- Namespace: $NAMESPACE"
        
        # Check if kubectl is working
        echo "ğŸ” Checking kubectl connection..."
        kubectl cluster-info || {
            echo "âŒ kubectl connection failed"
            echo "ğŸ’¡ Please check your KUBECONFIG secret"
            exit 1
        }
        
        # Deploy skill-repeater-front with version substitution
        echo "ğŸ” Deploying skill-repeater-front..."
        export IMAGE_VERSION=$VERSION
        export IMAGE_TAG=$IMAGE_TAG
        export DOCKERHUB_USERNAME=$DOCKERHUB_USERNAME
        
        # Create temporary skill-repeater-front.yaml with image substitution
        envsubst < k8s/skill-repeater-front.yaml | kubectl apply -f -
        
        # Wait for skill-repeater-front to be ready
        echo "â³ Waiting for skill-repeater-front to be ready..."
        kubectl wait --for=condition=available --timeout=300s deployment/skill-repeater-front -n $NAMESPACE
        
        # Verify deployment
        echo "âœ… Verifying deployment..."
        kubectl get pods -n $NAMESPACE
        kubectl get services -n $NAMESPACE
        
        echo "âœ… Skill-repeater-front deployment completed successfully!"
        
    - name: Run Production Tests
      run: |
        echo "ğŸ§ª Running production tests..."
        
        NAMESPACE="${{ secrets.K8S_NAMESPACE || 'skill-repeater' }}"
        
        # Get service information
        echo "ğŸ“‹ Service Information:"
        kubectl get service skill-repeater-front -n $NAMESPACE
        
        # Get pod status
        echo "ğŸ“Š Pod Status:"
        kubectl get pods -n $NAMESPACE -l app=skill-repeater-front
        
        # Check service endpoints
        echo "ğŸ” Checking service endpoints..."
        kubectl get endpoints skill-repeater-front -n $NAMESPACE
        
        # Health check using the correct endpoint
        echo "ğŸ¥ Running health checks..."
        echo "Testing frontend endpoint: https://repeaty.posadskiy.com"
        curl -f https://repeaty.posadskiy.com || echo "Health check failed"
        
        echo "âœ… Production tests completed"
        
    - name: Create Release
      if: github.event_name == 'push'  # Only create release on tag push
      env:
        GH_TOKEN: ${{ secrets.DEPLOYMENT_GITHUB_TOKEN }}
      run: |
        # Fetch all tags to ensure they're available
        git fetch --tags
        
        # Get the previous tag to determine commit range
        CURRENT_VERSION="${{ needs.build.outputs.version }}"
        
        # More robust approach to find previous tag
        PREVIOUS_TAG=$(git tag --sort=-version:refname | while read tag; do
        if [[ "$tag" != "v$CURRENT_VERSION" ]]; then
        echo "$tag"
        break
        fi
        done)
        
        # Use the previous tag for the commit range
        COMMIT_RANGE="$PREVIOUS_TAG..HEAD"
        
        # Create release body header
        echo "## Skill Repeater Frontend Release ${{ needs.build.outputs.version }}" > release_body.md
        echo "" >> release_body.md
        echo "### ğŸ“ Changes" >> release_body.md
        
        if [[ -n "$PREVIOUS_TAG" ]]; then
        # Get all commit messages in the range, excluding all version bump commits
        COMMITS=$(git log --pretty=format:"- %s" $COMMIT_RANGE | grep -v "^- v[0-9]" || echo "")
        if [[ -z "$COMMITS" ]]; then
        echo "No changes since previous release." >> release_body.md
        else
        echo "$COMMITS" >> release_body.md
        fi
        else
        # First release - include all commits except version bump commits
        COMMITS=$(git log --pretty=format:"- %s" | grep -v "^- v[0-9]" || echo "")
        if [[ -z "$COMMITS" ]]; then
        echo "No changes since previous release." >> release_body.md
        else
        echo "$COMMITS" >> release_body.md
        fi
        fi
        
        # Add footer to release notes
        echo "" >> release_body.md
        echo "### ğŸ“¦ Release Artifacts" >> release_body.md
        echo "- Source code tagged with version ${{ needs.build.outputs.version }}" >> release_body.md
        echo "- Docker image available in Docker Hub" >> release_body.md
        echo "" >> release_body.md
        echo "### ğŸ”§ Build Instructions" >> release_body.md
        echo '```bash' >> release_body.md
        echo "npm ci" >> release_body.md
        echo "npm run build" >> release_body.md
        echo "docker build -f Dockerfile.prod -t skill-repeater-front ." >> release_body.md
        echo '```' >> release_body.md
        echo "" >> release_body.md
        echo "### ğŸ“ Release Trigger" >> release_body.md
        if [[ "${{ needs.build.outputs.trigger_type }}" == "manual" ]]; then
        echo "This release was triggered by a manual workflow dispatch." >> release_body.md
        else
        echo "This release was triggered by a git tag push." >> release_body.md
        fi
        
        # Create release using GitHub CLI
        gh release create ${{ needs.build.outputs.tag }} \
        --title "Skill Repeater Frontend ${{ needs.build.outputs.version }}" \
        --notes-file release_body.md \
        --draft=false \
        --prerelease=false

  # Monitoring and Alerting
  monitor:
    name: Monitor Deployment
    runs-on: ubuntu-latest
    needs: deploy-production
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      
    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config
        
    - name: Monitor Application Health
      run: |
        echo "ğŸ“Š Monitoring application health..."
        
        NAMESPACE="${{ secrets.K8S_NAMESPACE || 'skill-repeater' }}"
        
        # Check if kubectl is working
        echo "ğŸ” Testing kubectl connection..."
        kubectl cluster-info || {
            echo "âŒ kubectl connection failed"
            echo "ğŸ’¡ This might be due to cluster access issues or authentication problems"
            exit 1
        }
        
        # Get pod status and resource usage
        echo "ğŸ“Š Pod Status and Resource Usage:"
        kubectl get pods -n $NAMESPACE -l app=skill-repeater-front || echo "No skill-repeater-front pods found"
        kubectl top pods -n $NAMESPACE -l app=skill-repeater-front || echo "Resource usage not available"
        
        # Get service status
        echo "ğŸŒ Service Status:"
        kubectl get services -n $NAMESPACE -l app=skill-repeater-front || echo "No skill-repeater-front services found"
        
        # Get deployment status
        echo "ğŸš€ Deployment Status:"
        kubectl get deployments -n $NAMESPACE -l app=skill-repeater-front || echo "No skill-repeater-front deployments found"
        
        # Check logs for any errors
        echo "ğŸ“ Recent Logs:"
        kubectl logs --tail=50 -n $NAMESPACE -l app=skill-repeater-front || echo "No logs available"
        
        # External health check
        echo "ğŸ¥ External Health Check:"
        curl -f https://repeaty.posadskiy.com || echo "External health check failed"
        
        echo "âœ… Monitoring completed" 